#!/usr/bin/python

import time
import argparse
from jira import JIRA
import dateutil.parser as dtime
from config.settings import *
from collections import namedtuple


class JiraCli:
  def __init__(self, args):
    self.args = args
  
  def create(self):
    '''
      Create new issue by providing dictionary of data

      Here I faced a problem, by using REST API service
      creating a new issue continuously returning 400 error from the server says
      transition and assigner missing, by that I decided to use jira library for the whole project
      but in the upcoming versions I'll resolve the problem.
    '''
    issue_dict = {
      'project': {'key': self.args.projectKey},
      'summary': self.args.issueSummary or '',
      'description': self.args.issueDescription,
      'issuetype': {'name': self.args.issueType},
    }
    new_issue = self.auth.create_issue(fields=issue_dict)
    print('\nIssue created successfully, issue key:', new_issue, '\n')

  def dump(self):
    '''
      Dump data of the given parameter
      issues or projects
    '''
    if self.args.dump == 'projects':
      projects = self.auth.projects()
      for project in projects:
        text = f'ID = {project.id}\n'
        text += f'Key = {project.key}\n'
        text += f'Name = {project.name}\n'
        text += '-------------------------'
        print(text)
    else:
      if self.args.issueKey and not self.args.projectKey:
        issues = self.auth.issue(self.args.issueKey)
      else:
        issues = self.global_search(jql_query=f'project={self.args.projectKey}')

      self.get_data(issues=issues)

  def transition(self):
    '''
      Implement transition on issue
      To Do = 11
      In Progress = 21
      In Review = 31
      Done = 41 or 31
    '''
    if self.args.transitionId:
      issue = self.auth.issue(self.args.issueKey)
      transitions = self.auth.transitions(issue)
      self.auth.transition_issue(self.args.issueKey, self.args.transitionId)

  def delete(self):
    '''
      Delete an issue by the given issueKey
    '''
    if self.args.issueKey:
      issue = self.auth.issue(self.args.issueKey)
      issue.delete()

  def close(self):
    '''
      Close an issue by sitting it status to Done
    '''
    if self.args.issueKey:
      issue = self.auth.issue(self.args.issueKey)
      transitions = self.auth.transitions(issue)
      self.auth.transition_issue(self.args.issueKey, '31')

  def comment(self):
    '''
      Comment on issue
    '''
    if self.args.issueKey:
      self.auth.add_comment(self.args.issueKey, self.args.commentBody, visibility={'type': 'role', 'value': 'Administrator'})

  def global_search(self, jql_query):
    query = self.auth.search_issues(jql_query)
    self.get_data(query)

  def filter(self):
    fi = f''
    
    if self.args.projectKey:
      progs = [pr.replace(" ", '', 1) for pr in self.args.projectKey.split(',')]

      if len(progs) > 1:
        fi += f'project in {tuple(progs)} '

      else:
        fi += f'project={self.args.projectKey} '

      if self.args.text:
        fi += f'AND text ~ "{self.args.text}"'

      if self.args.status:

        if not isinstance(self.args.status, str):
          print('Status must be a list of strings seperated by comma, for example: "To Do, In progress"')
          return

        status = [st.replace(" ", '', 1) for st in self.args.status.split(',')]

        if len(status) > 1:
          fi += f' AND status in {tuple(status)}'

        else:
          fi += f' AND status in ("{self.args.status}")'

      if self.args.myIssues:
        fi += f' AND assignee in (currentUser())'

      if self.args.issuetype:

        if not isinstance(self.args.issuetype, str):
          print('Issue types must be a list of strings seperated by comma, for example: "Task, Bug"')
          return

        types = [tp.replace(" ", '', 1) for tp in self.args.issuetype.split(',')]

        if len(types) > 1:
          fi += f' AND issuetype in {tuple(types)}'

        else:
          fi += f' AND issuetype in ("{self.args.issuetype}")'

      print("Filter:", fi, '\n')
      self.global_search(fi)
      # return fi
    else:
      print('--projectKey is required.')
      return

  def get_data(self, issues):
    if isinstance(issues, list):
      print('Issues found:', len(issues), '\n')
      time.sleep(3)
      for issue in issues:
        created_dtime = self.dtime_formater(issue.fields.created)
        content = f'Ticket number = {issue}\n'
        content += f'Creator = {issue.fields.creator}\n'
        content += f'IssueType = {issue.fields.issuetype.name}\n'
        content += f'Status = {issue.fields.status.name}\n'
        content += f'Summary = {issue.fields.summary}\n'
        content += f'Description = {issue.fields.description}\n'
        content += f'Votes = {issue.fields.votes.votes}\n'
        content += f'Created = {created_dtime.strftime("%d-%m-%Y %H:%M:%S")}\n'
        content += f'========================================\n'
        print(content)
    else:
      single_issue = f'Project name = {issues.fields.project}\n'
      single_issue += f'Ticket number = {issues}\n'
      single_issue += f'Creator = {issues.fields.creator}\n'
      single_issue += f'IssueType = {issues.fields.issuetype.name}\n'
      single_issue += f'Status = {issues.fields.status.name}\n'
      single_issue += f'Summary = {issues.fields.summary}\n'
      single_issue += f'Description = {issues.fields.description}\n'
      single_issue += f'Issue Link = {MAIN_URL}rest/api/3/issue/{self.args.issueKey}'
      print(single_issue)

  @property
  def auth(self):
    '''
      Basic authorization for JIRA
    '''
    auth_jira = JIRA(MAIN_URL, basic_auth=(AUTH_USER, AUTH_TOKEN))
    return auth_jira
  
  def dtime_formater(self, date) -> str:
    return dtime.parse(date)

  def getter(self, args):
    '''
      Future function to convert dictionary keys into properties
    '''
    return namedtuple('Dict', ' '.join(list(args.keys())))(**args)

def main_func(args):
  """
  Initialize main class
  """
  akcli = JiraCli(args)

  if args.create:
    akcli.create()

  if args.dump:
    akcli.dump()

  if args.delete:
    akcli.delete()

  if args.close:
    akcli.close()

  if args.comment:
    akcli.comment()

  if args.transition:
    akcli.transition()

  if args.filter:
    akcli.filter()


if __name__ == '__main__':
  # create the top-level parser
  parser = argparse.ArgumentParser(prog='JIRA Command Line Interface')
  parser.add_argument('--issueKey', dest="issueKey", help='issue key or id')
  parser.add_argument('--projectKey', dest="projectKey", help='issue key or id')


  # Create issue
  parser.add_argument('--create', action='store_true', help='create an issue')
  create_sub_parse = parser.add_subparsers(help='sub commands for creating issue')
  sub_create = create_sub_parse.add_parser('issue', help='create issue is sub-command with sub-commands')
  sub_create.add_argument('--issueType', required=True, type=str, help='issue type')
  sub_create.add_argument('--issueDescription', required=True, type=str, help='issue description')
  sub_create.add_argument('--issueSummary', required=True, type=str, help='issue summary')

  # Dump issue
  parser.add_argument('--dump',
    default=None,
    nargs='?',
    choices=['issues', 'projects'],
    help='dump projects, issues, (default: %(default)s)'
  )

  # Delete issue
  parser.add_argument('--delete', action='store_true', help='delete an issue')

  # Close an issue
  parser.add_argument('--close', action='store_true', help='delete an issue')

  # Do transition
  parser.add_argument('--transition', action='store_true', help='transit an issue')
  parser.add_argument(
    '--transitionId',
    type=int,
    dest="transitionId",
    choices=[11, 21, 31, 41],
    help='transit an issue'
  )

  # Comment on issue
  parser.add_argument('--comment', action='store_true', help='comment on issue')
  parser.add_argument('--commentBody', dest="commentBody", help='comment body')

  # Filter
  parser.add_argument('--filter', action='store_true', help='Advanced filter')
  parser.add_argument('--issuetype', help='Filter by issue type')
  parser.add_argument('--text', help='Filter by text or description')
  parser.add_argument('--myIssues', help='Filter only my issues')
  parser.add_argument('--status', help='Filter by status')

  args = parser.parse_args()

  main_func(args)
